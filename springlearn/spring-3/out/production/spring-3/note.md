## 基于注解方式的 aop- 加入 jar 包：        与 aop 相关:    - com.springsource.org.aopalliance-1.0.0.jar<br/>    - com.springsource.org.aspectj.weaver-1.6.8.RELEASE.jar<br/>    - spring-aspects-4.3.14.RELEASE.jar<br/>    - spring-aop-4.3.14.RELEASE.jar<br/>    常用:<br/>    commons-logging-1.2.jar<br/>    spring-beans-4.3.14.RELEASE.jar<br/>    spring-context-4.3.14.RELEASE.jar<br/>    spring-core-4.3.14.RELEASE.jar<br/>    spring-expression-4.3.14.RELEASE.jar<br/>    - 在 spring IoC 容器加入 aop 命令空间并加入如下配置: <!-- 使用 aspectj 起作用：自动匹配相应的类生成代理对象 --> <aop:aspectj-autoproxy />- 把横切关注点的代码抽象到切面的类中 - 使用 @Component 声明该类是 IoC 容器的一个 Bean  -  使用 @Aspect 声明该类是一个切面        在切面类声明各种通知：    - @Before: 前置通知, 在方法执行之前执行    - @After: 后置通知, 在方法执行之后执行 [无论是否异常]    - @AfterRunning: 返回通知, 在方法返回结果之后执行[返回参数 throwing 的值与方法的异常参数名要一致,方法的异常类型可以指定，指定有则执行，无则不执行]     - @AfterThrowing: 异常通知, 在方法抛出异常之后[异常参数 returning 的值与方法的返回参数名要一致]     - @Around: 环绕通知, 围绕着方法执行[该相当一个完整的代理过程 与 ProceedingJoinPoint 参数共同使用，并且方法有返回值]- 可以在通知方法中声明一个类型为 JoinPoint 的参数，然后就能访问链接细节，如方法名称和参数值```java         @Around(value="declareJointPointExpression()")            public Object arounMethod(ProceedingJoinPoint joinPoint){                String methodName = joinPoint.getClass().getName();                List<Object> args = Arrays.asList(joinPoint.getArgs());                Object result = null;                try {                    // 前置通知                    System.out.println("The method " + methodName + " with " + args);                    // 执行方法                    result = joinPoint.proceed();                    // 返回通知                    System.out.println("The method " + methodName + " end " + result);                } catch (Throwable throwable) {                    throwable.printStackTrace();                    // 异常通知                    System.out.println("The method " + methodName + " ocrrous thorw " + throwable);                }                // 后置通知                System.out.println("The method " + methodName + " end " + result);                return result;            }```      - 最典型的切入点表达式时根据方法的签名来匹配各种方法:    - execution * com.atguigu.spring.ArithmeticCalculator.*(..): 匹配 ArithmeticCalculator 中声明的所有方法,第一个 * 代表任意修饰符及任意返回值. 第二个 * 代表任意方法. .. 匹配任意数量的参数. 若目标类与接口与该切面在同一个包中, 可以省略包名.    - execution public * ArithmeticCalculator.*(..): 匹配 ArithmeticCalculator 接口的所有公有方法.    - execution public double ArithmeticCalculator.*(..): 匹配 ArithmeticCalculator 中返回 double 类型数值的方法    - execution public double ArithmeticCalculator.*(double, ..): 匹配第一个参数为 double 类型的方法, .. 匹配任意数量任意类型的参数    - execution public double ArithmeticCalculator.*(double, double): 匹配参数类型为 double, double 类型的方法. - 重用切面关注点表达式: - 定义一个方法, 用于声明切入点表达式. 一般地, 该方法中再不需要添入其他的代码. - 使用 @Pointcut 来声明切入点表达式. - 后面的其他通知直接使用方法名来引用当前的切入点表达式.   ## 基于 IoC 容器配置方式